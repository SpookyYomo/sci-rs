fn poly(cof: &[f64], x: f64) -> f64 {
    cof[..cof.len() - 1]
        .iter()
        .rev()
        .fold(*cof.last().expect("Coefficients are empty!"), |acc, e| {
            acc * x + e
        })
}

const I0P: [f64; 14] = [
    9.999999999999997e-1,
    2.466405579426905e-1,
    1.478980363444585e-2,
    3.826993559940360e-4,
    5.395676869878828e-6,
    4.700912200921704e-8,
    2.733894920915608e-10,
    1.115830108455192e-12,
    3.301093025084127e-15,
    7.209167098020555e-18,
    1.166898488777214e-20,
    1.378948246502109e-23,
    1.124884061857506e-26,
    5.498556929587117e-30,
];

const I0Q: [f64; 5] = [
    4.463598170691436e-1,
    1.702205745042606e-3,
    2.792125684538934e-6,
    2.369902034785866e-9,
    8.965900179621208e-13,
];

const I0PP: [f64; 5] = [
    1.192273748120670e-1,
    1.947452015979746e-1,
    7.629241821600588e-2,
    8.474903580801549e-3,
    2.023821945835647e-4,
];

const I0QQ: [f64; 6] = [
    2.962898424533095e-1,
    4.866115913196384e-1,
    1.938352806477617e-1,
    2.261671093400046e-2,
    6.450448095075585e-4,
    1.529835782400450e-6,
];

pub fn i0(x: f64) -> f64 {
    let ax = f64::abs(x);
    match ax < 15.0 {
        true => poly(&I0P, x * x) / poly(&I0Q, 225. - (x * x)),
        false => {
            f64::exp(ax) * poly(&I0PP, 1.0 - 15.0 / ax)
                / (poly(&I0QQ, 1.0 - 15.0 / ax) * f64::sqrt(ax))
        }
    }
}
